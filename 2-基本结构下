什么是队列
队列是一种有次序的数据集合，其特征是
新数据项的添加总发生在一端(通常称为"尾rear"端)
而现存数据项的移除总发生在另一端(通常称为"首front"端)
当数据项加入队列，首先出现在队尾随着队首数据项的移除，它逐渐接近队首


新加入的数据项必须在数据集末尾等待，而等待时间最长的数据项则是队首
这种次序安排的原则称为（FIFO：First-in first-out）先进先出

队列仅有一个入口和出口
不允许数据项直接插入队中，也不允许从中间移除数据项

计算机科学中队列的例子：打印机、进程调度、键盘缓冲
进程数远多于CPU核心数
有些进程还要等待不同类型的I/O事件

抽象数据类型Queue
Queue():创建一个空队列对象，返回值为：Queue对象
enqueue(item)：将数据项item添加到队尾，无返回值
dequeue():从队首移除数据项，返回值为队首数据项，队列被修改
isEmpty()：测试是否空队列，返回值为布尔值
size():返回队列中数据项的个数
采用List来容纳Queue的数据项
将List首端作为队列尾端
List的末端作为队列首端
enqueue()复杂度为O(n)
dequeue()复杂度为O(1)
首尾倒过来的实现，复杂度也倒过来

class Queue:
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []
    def enqueue(self,item):
        self.items.insert(0,item)
    def dequeue(self):
        return self.item.pop()
    def size(self):
        return len(self.items)
    
 队列的应用：热土豆问题(约瑟夫问题)
 模拟程序采用队列来存放所有参加游戏的人名，
 按照传递土豆方向从队首排到队尾
 游戏时，队首始终是持有土豆的人
 
 模拟游戏开始，只需要将队首的人出队，随即再到队尾入队，算是土豆的一次传递
 传递了num次后，将队首的人移除，不再入队，由后面的人拿起继续传进行游戏，最后留下来的为胜者，如此反复，直到队列中剩余一人
 
 
from pythonds.basic.queue import Queue
def hotPotato(namelist,num):
    simqueue = Queue()
    for name in namelist:
        simqueue.enqueue(name)
    while simqueue.size() > 1:
        for i in range(num):
            simqueue.enqueue(simqueue.dequeue())
        simqueue.dequeue()
    return simqueue.dequeue()
print(hotPotato(["Bill","David","Susan","Jane","Kent","Brad"],7))
 
>>>
Susan
队列的应用:打印任务
多人共享一台打印机，采取"先到先服务"的队列策略来执行打印任务
在这种设定下，一个首要的问题就是：
这种打印作业系统的容量有多大？
在能够接受的等待时间内，系统能容纳多少用户以多高频率提交多少打印任务

一个具体的实例配置如下：
一个实验室，在任意的一个小时内，大约有10名学生在场
这一小时中，每人会发起2次左右的打印，每次1-20页
打印机的性能是:
以草稿模式打印的话，每分钟10页
以正常模式打印的话，打印质量好，但速度下降为每分钟5页
问题是：怎么设定打印机的模式，让大家都不会等太久的前提下尽量提高打印质量？
这是一个典型的决策智齿问题，但无法通过规则直接计算
我们要用一段程序来模拟这种打印任务场景，然后对程序运行结果进行分析，以支持对打印机模式设定的决策

对象：打印任务，打印队列、打印机

打印任务的属性：提交时间，打印页数
打印队列的属性:具有FIFO性质的打印任务队列
打印机的属性：打印速度，是否忙

过程：生成和提交打印任务
确定生成概率：实例为每小时会有10个学生提交的20个作业，这样，概率是每180秒会有1个作业生成并提交，概率为每秒1/180
确定打印页数：实例是1~20页，那么就是1~20页之间概率相同


过程:实施打印
当前的打印作业：正在打印的作业
打印结束倒计时：新作业开始打印时开始倒计时，回0表示打印完毕，可以处理下一个作业

模拟时间：
统一的时间框架：以最小单位（秒）均匀流逝的时间，设定结束时间
同步所有过程：在一个时间单位里，对生成打印任务和实施打印量而过程各处理一次


双端队列Deque
跟队列相似，其两端可以称作"首""尾"端，但deque中数据项计可以从队首加入，
也可以从队尾加入：数据项也可以从两端移除
某种意义上说，双端队列集成了栈和队列的能力

抽象数据类型Deque
deque定义的操作如下：
Deque():创建一个空双端队列
addFront(item):将item加入队首
addRear(item):将item加入队尾
removeFront():从队首移除数据项，返回值为移除的数据项
removeRear()：从队尾移除数据项，返回值为移除的数据项
isEmpty():返回deque是否为空
size():返回deque中包含数据项的个数

#左边是队尾，右边是队尾

python实现ADT Deque
采用List实现
List下标0作为deque的尾端
List下标-1作为deque的首端

操作复杂度
addFront/removeFont O(1)
addRear/removeRear  O(n)


class Deque:
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []
    def addFont(self,item):
        self.items.append(item)
    def addRear(self,item):
        self.items.insert(0,item)
    def removeFront(self):
        return self.items.pop()
    def removeRear(self):
        return self.items.pop(0)
    def size(self):
        return len(self.items)

"回文词判定"
用双端队列很容易解决"回文词"问题
先将需要判定的词从队尾加入deque
再从两端同时移除字符判定是否相同，直到deque中剩下0个或1个字符
from pythonds.basic.deque import Deque
def palchecker(aString):
    chardeque = Deque()
    for ch in aString:
        chardeque.addRear(ch)
    stillEqual = True
    while chardeque.size()>1 and stillEqual:
        first = chardeque.removeFront()
        last = chardeque.removeRear()
        if first != last:
            stillEqual = False
    return stillEqual
print(palchecker("lsdkjfskf"))
print(palchecker("radar"))
>>>
False
True


无序表抽象数据类型
































 
 
 
 
 
 
    
    
    
    
    
    
    
    
    
    
    
    
